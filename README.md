# ACM-Day3
1. Priority Queue（Aizu - ALDS1_9_C ）
·思路：
该题的要点在于判断操作为录入数据，读取数据还是结束运行。可以用if语句判断输入前半部分的字符内容。
·总结：
注意优先队列的性质，默认为大根堆（只能查询或删除最大的数），小根堆的格式为 priority_queue<int, vector<int>,greater<int> > p;
2. ST 表 && RMQ 问题（洛谷-P3865）
·思路：
若用暴力求解，每次都对区间 [l,r] 扫描一遍显然会超时。而ST表基于倍增的思想,可以实现O(nlogn)下进行预处理，并在0(1)时间内回答每个询问。套用ST表公式即可。
·总结：
ST表是一种基于倍增思想，可用于解决可重复贡献问题的数据结构。可重复贡献问题:对于运算满足opt有xoptx = x，则对应的区间询问就是一个可重复贡献问题。该题求询问范围的最大值，需要反复比对数据，就是一种可重复贡献问题。
3. 合并果子（洛谷-P1090）
·思路：
为了省力，需要不断将目前最轻的两堆水果合并（越重的越后合并）。可使用小根堆的优先队列，设置while循环读取并删除目前最小的两个水果堆（读一个删一个），然后将二者相加形成新堆，加回到队列中进行下一轮比较；直到队列中只剩下最后一个元素（即最后合成的水果堆）。在循环外初始化一个变量，记录每次合成的操作并进行累加，该变量则为最小体力。
·总结：
通过优先队列可直接查询或删除数据中的最大或最小值。可解决如该题这种带有反复叠加值的求最小值问题。
4. 约瑟夫问题（洛谷-P1996）
·思路：
可以把该题看成一个环形队列，不断取出周期元素。为了完成头尾循环的效果，可使用队列，不断取出队首元素。再设置一个计数器变量检查该元素的位置是否等于“周期”，若不是，再塞回队尾；若是，直接输出，同时清零计数器。
·总结：
可用队列解决类似的循环周期问题。队列的性质：先进先出，可从队尾加入元素，但只能查询或删除队首元素（第一个加入的元素），不支持随机访问，且为了保证数据的严格有序性，不支持迭代器。
5. Look Up S（洛谷 - P2947）
·思路：
原本想用ST表解决区域最大值问题，但发现较难实现输出序号的操作。因此改用栈的方式解决。设置一个栈来存储比当前奶牛的“仰望奶牛”序号，如果当前栈满，且栈顶序号的奶牛高度小于当前奶牛高度（说明该奶牛更高），就删除栈顶，再将当前奶牛与新栈顶比较。通过反复检查栈来判断该奶牛是否有对应的“仰望奶牛”：如果栈为空，说明无“仰望奶牛”，往存放答案的数组中输入“0”；如不为空，往答案数组输入当前栈顶。最后把当前奶牛的序号存到栈中。注意：由于要找向右（向后）的仰望对象，所以用倒序先处理最后一个元素，（如果要找向左的，可以用顺序）
·总结：
解决该类需要反复查询区域最大值，并返回最大值位置的题目，可用栈来存放最大值的下标，并通过栈的性质反复更新最大值。栈的性质：后进后出，只能查询或删除最后一个加入的元素（栈顶元素），不支持随机访问，且为了保证数据的严格有序性，不支持迭代器。


